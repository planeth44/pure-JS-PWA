--- 2022-10-16 ---
- [ ] app should have a mechanism to try a sync whenever the need is
  - [ ] store a lastRefreshTs mechanism to throttle call to sync
  - [ ] store a needSync bool
  - [ ] call a sync whenever both lastRefreshTs && needSync agree
  - [ ] should be a method in app.js
- [ ] add an option to clear user-notification after timeout
- [ ] add manifest for installability
- [ ] consider using Web Notification when background-sync fail the 3 tries 
  ->  as the app may be in background
  -> service-worker:96
 :LATER:EXPLORE:
- [ ] Generate list page after done in edit
  -> Sync happens in @done
  -> Sync status would change immediately
  -> Case to consider in case of long list of things

~ UI
- [ ] Navbar at bottom [home | Things | +] / menu [failed page | create thing]
- [-] Failed page
  - [ ] preview image ??

~ DESIGN
:EXPLORE:
- [-] Syncing / update of theModel [1/5]
  - [X] add a version in theModel
  - [ ] call to sync should send uuid + version 
  - [ ] response to sync should send diff on LastModifiedTimestamp+version
  - [ ] call update on response
  - [ ] modelController should set syncStatus=update when necessary
  - [ ] Stub on server ??
:EXPLORE:
- [ ] implementing images caching after upload/sync to distant server
  - see syncController@cachePhoto
  - URL could be in the form of images/<parentUuid>/<uuid>
:EXPLORE:CONSIDER:
- [ ] making a Model class with method getFromPath, setFRomPath, toFormData 

~ REFACTOR
:LATER:CONSIDER:
- [ ] refactor syncController. Extract call to fetch to its own method
   Catch a 401 [[https://github.com/github/fetch/issues/201#issuecomment-308213104]]
   [[https://web.dev/fetch-api-error-handling/]]
   [[https://scribe.rip/trabe/fetch-api-errors-and-the-principle-of-least-surprise-66bbba3e4cc2]]



~ DONE
- [-] Failed page
  - [X] link to parent 
- [X] Organize functions in modelController
-> object actions
-> form / errors management
- [X] Home page / sync state 
-> Should recalculate if some object failed to sync
-> Should show failed objects
- [X] Do not display error HTML on failed sync/ store in iDB 
- [X] implement /document/failed view + controller
- [X] /edit Show message on invalid fields
- [X] Style error list in edit page
- [X] Document case of preventing or not sync if invalid local data
- [X] Do not sync data if invalid
-> sync state should be 'invalid-data'
- [X] SyncController : 
-> Do not throw on error
-> Cache message or publish user notif
-> AND CONTINUE TO NEXT
- [X] Notify or update
-> App.js should dispatch to home
-> Homecontroller decides what to do
- [X] Check for create Thing -> What's the URL See above
- [X] User message
-> Go through all & decide where it belongs notify or update
- [X] postMessage -> Case for update or notify in app.js not SW
- [X] Decomment catch on fetch 
  -> Provide for background-sync not available
- [X] Home page -> add method to check for pending instances
- [X] Add an action to sync without being in edit page + trigger a 'done'
- [X] refactor syncStatus values as const in ???
- [X] Implement background-sync
- [X] ModelController. Done button should trigger validation. And stop to ask to change if need
- [X] Display files & photos in /edit/<uuid>
- [X] ModelController. [4/4]
  - [X] Cancel button should remove the instance in iDB 
  - [X] If yes remove associated docs
  - [X] For now reset clear all the fields but the model is not cleared. 
  - [X]   Should ask the user if want to clear the model
- [X] Sync w/ distant server 
- [X] fileController should have the fileModel at the top
- [X] style user.notification / should be less present
- [X] remove all flpwa- classes
- [X] extract fc to camelCase updateFormControls@method
- [X] add a /ops route w/ JS only to test & do stuff
- [X] test offline mode when trying to sync [3/3]
  - [X] test server off
  - [X] test server respond with 500
  - [X] test server respond with 400

* README
- non negociable : performance. Minimum amont of LoC .
- Snappy page
- light weight app (140KB nonziped/noncompressed) 
- PWA
- Closest as possible to web API
- make use of every native API : service worker, module, 
- Go for the least amount of code and the least amout of abstraction
- Multi page rather than single page
  - no router, use SW precache and route
  - Browser are super fact at parsing HTML
  - No state management
  - One controller per page (see locality of behavior)
  - DB operations in controller
- Locality of behavior (one controller for the page)
- CSS 
  => picnic
- Things
  - Things are created via forms
  - store all Things in iDB
- Use HTML form controls
  -> you get build in behavior / UI
  -> you get build in event
  -> you get build in validation
- form controls are mapped to model properties
  - wrote a little helper function to get or set a property from control[name] as path
  - this make it possible to have a deeply nested object Thing
  - there is another 
- Files are a separate issue
  - file are stored as arrayBuffer (iOS does not support blob in iDB)
  - are dependent on the parent Thing
  - all the file methods are in their own controller 
- Auto save is a given UI
  - Make use of change event
  - need to transform formData to storable Things
  - update the model property from the form control
  - with some additional control
  - you can overide the default updating with data-change attribute
    -> this let you do some computation on the new value
    -> or even set other object property (example in changeHandler)
  - alternatiely with a simpler mapping, there is an example from Jake Archibald
- Form error validation
  - novalidate
  - form can get long
  - or we could add form controls along the way
  - Validation is called w/ submit event
  - show list of errors and messages on fields
  - then call to sync
- Biggest chunk : syncing w/ offine
  - Making use of background-sync but need fallback
    -> iOS/ Firefox does not support background-sync
  - Cases for failed sync and retry
  -> background-sync will not support all the cases
    in fact does only one thing: retry if offline(airplane mode).
    Does not always idetify an offline situation
  - Either the app or the user must have a way to know what is the state of the sync
  - right now: user is responsible
  - but should not rely either on background-sync or user 
    - or SW starting (or should we ?)
  - files are sent w/ PUT method in binary form. 
    - iOS quirk again. No support for formData.append file in SW
    - with this solution we dont rely on polyfill
  - update
    - this is dependent on server, but
    - server is the source of confidence as the server cannot call the client but the inverse is true
      - client should call a sync from the server whenever it needs to check for update on Things
      - Server responds w/ version number + lastUpdatedTimestamp
      - If conflict arise (version number does not match) when syncing from client in case of no prior sync/ offline situation when updating a Thing, server should reject the sync and reply w/ its own version of the Thing
        - Client should then store the versioned Thing ?
          - then how should we choreograph the dance to resolve the conflict
          - alert the user
          - show the 2 version (how ? side by side ? Field by field ?)
          - make a UI to merge the 2 versions, field by field ?
        - Simpler solution : works if sync happens in front of the user 
          client tell that a conflict exists & replace the Thing w/ the server version. But we lose the update from client.
- Repo has a very rustic back-end server to just respond to api calls(sync)
- Dependencies
  - Workbox. Service worker API is very low level
  Just makes sense to use this library
  precache an route essential to MPA whitout a round trip to the server
  Only include needed components
  Not using their backgroundSync component (the use case is too limited)
  - iDB from Jake Archibald
  very small and worth ten time the footprint
  indexedDB is old and asynchronous. This library promisify it and make it easier to work with
  - that's all